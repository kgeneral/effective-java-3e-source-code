## Item 10. equals 는 일반 규약을 지켜 재정의(override)하라

- overriding equals 를 권장하지 않는 경우

> 1. inherently unique 한 경우 : 각 instance 가 value 가 아닌 activity 에 의미가 있는 경우 (Thread)
> 2. instance 간의 logical	equality 를 검사할 필요가 없다 : Object.equals (물리적으로 같은 instance 일때 equal 로 판단)
> 3. 이 class 의 superclass 에 정의된 equals가 활용가능(적합)하다 : Set, Map 의 구현체들
> 4. package-private, private class 들 : equals 를 호출할 일이 없는 경우

- 그럼 언제 재정의 하라는 거?

> logical	equality 검사가 필요한 데, 이 class 의 superclass.equals 에 적절하게 구현되어 있지 않은 경우
```
i.e) List.contains(x) 시 x class 내부 필드 중 unique 기준을 일부로 선별하고 싶을 때

value class 라 할지라도 동일 value 를 가진 instance 가 1개인 것이 보장된다면 override 불필요(Enum, String 등)
```

- equals method 의 규약 (specification for 'Object')

```
for any non-null x, y, z
```
> 1. Reflexive : x.equals(x) 
> 2. Symmetric : if x.equals(y) than y.equals(x)
> 3. Transitive : if x.equals(y) and y.equals(z) than	x.equals(z)
> 4. Consistent : x.equals(y) must consistently return true	or consistently return false 
> 5. x.equals(null) == false

TODO : show examples for above

## Item 11. equals 재정의(override) 시 hashCode 도 재정의하라

- hashCode method 의 규약 (specification for 'Object')

> 1. hashCode 는 동일 어플리케이션 안에서, equals 에 영향을 주는 내부 필드가 변경되지 않는 한 동일 값을 반환한다. 
> 2. if x.equals(y) than x.hashCode() == y.hashCode()
> 3. Not reqiured to x.hashCode() != y.hashCode() even if x.equals(y) == false (but recommended for performance of hash tables)
```
서로 다른 value 가 hash collision 발생시, linked list 등으로 연결되어 put/get 성능에 영향( > O(1) )을 끼칠 수 있다.

* 2번 규약의 경우, 지켜지지 않을 시 Hashing 을 활용하는 자료구조에서 문제가 발생한다.
Map<PhoneNumber, String> m = new HashMap<>(); 
m.put(new	PhoneNumber(707, 867, 5309), "Jenny");

m.get(new	PhoneNumber(707, 867, 5309); // null
```

- hashCode 구현의 형태
```
// 전통(?)적인 hashCode 구현
// 31은 홀수+소수이고 31 * i = (i << 5) - i 처럼 VM내부 시프트 최적화에 좋아서 쓴다고 한다.
@Override public int hashCode() {
  int result = Short.hashCode(areaCode);
  result = 31 * result + Short.hashCode(prefix);
  result = 31 * result + Short.hashCode(lineNum);
  return result;
}

// java 7+ 에 제공되는 hash. 성능이 아쉽다고 책에 나와잇으나 실제로 jdk 소스 보면 위쪽 코드와 비슷하다.
@Override public int hashCode() {
  return Objects.hash(lineNum, prefix, areaCode);
}

// lazy initialization. 굳이 이렇게 까지 쓰나?
private int hashCode; // Automatically initialized to 0
@Override public int hashCode() {
  int result = hashCode;
  if (result == 0) {
    result = Short.hashCode(areaCode);
    result = 31 * result + Short.hashCode(prefix);
    result = 31 * result + Short.hashCode(lineNum);
    hashCode = result;
  }
  return result;
}
```

**hashCode 에 활용될 필드는, 결과 hash 가 높은 cardinality 를 가지도록 잘 선별해야 성능에 유리하다**

**hashCode 출력 값을 클라이언트가 직접 의존하는 것은 안좋다. 필드 추가/삭제에 영향이 크기 때문**


## Item 12. toString 을 항상 재정의(override)하라

- toString() 은 logging 시 개발자의 디버깅 효율을 높혀주는 데 유리하게 활용될 수 잇다.
```
System.out.println("Failed to connect to " + phoneNumber); // Failed to connect to PhoneNumber@163b91 

// PhoneNumber class
@Override public String toString() {
  return String.format("%03d-%03d-%04d", areaCode, prefix, lineNum);
}

System.out.println("Failed to connect to " + phoneNumber); // Failed to connect to 010-1577-1577

```

- 주요 필드(해당 value 를 대표할 수 잇는 필드)의 경우 toString 에 추가해 주는 것이 좋다.
```
value class 라면 equals 조건에 쓰이는 필드 전부, list class 라면 목록의 개수 등
```

- toString() 결과에 대해 '고정 포맷'을 제공하는 것인지, 임의 변경 가능한 것인지 명확히 전달해줄 것 (클라가 멋대로 파싱해서 쓰지 않도록)
- toString() 에 표시되는 필드에 대해서는 전부 getter 를 제공 하는 것을 권장
- AutoValue? Lombok? : 
  - https://codeburst.io/lombok-autovalue-and-immutables-or-how-to-write-less-and-better-code-returns-2b2e9273f877
  - https://medium.com/@vgonzalo/dont-use-lombok-672418daa819




## Item 13. clone 재정의(override)는 주의하여 진행하라

## Item 14. Comparable 을 구현할지 고려하라
